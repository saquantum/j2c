genST* attachMethodTypeBoundList(treeNode* typeBoundList) {
    if (!typeBoundList) {
        return NULL;
    }

    // Create a root genST to hold the type bound list
    genST* root = calloc(1, sizeof(genST));
    if (!root) {
        fprintf(stderr, "Error: Not enough memory to create method type bound list.\n");
        exit(1);
    }

    root->cf = GEN_ST;
    root->nestedCount = countCommas(typeBoundList) + 1; // Count type bounds
    root->nested = calloc(root->nestedCount, sizeof(genST*));
    if (!root->nested) {
        fprintf(stderr, "Error: Not enough memory for nested type bounds.\n");
        exit(1);
    }

    size_t idx = 0;

    // Process each type argument in the type bound list
    for (size_t i = 0; i < typeBoundList->childCount; i++) {
        treeNode* child = typeBoundList->children[i];

        if (child->ruleType == typeArgument_rule) {
            root->nested[idx] = attachGenericsSymbolTable(NULL, child);
            idx++;
        }
    }

    return root;
}
